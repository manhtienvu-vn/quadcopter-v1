/*
 * MPU6050.c
 *
 *      Author: Manh Tien Vu
 */
#include <main.h>
#include "MPU6050.h"
#include "math.h"
#include "stdbool.h"

#define RAD_2_DEG   57.29578f // [deg/rad]
#define TEMP_LSB_2_DEGREE 131.0f   // [bit/celsius]
#define TEMP_LSB_OFFSET 16384.0f
uint8_t RETURN_DATA;
uint8_t mData;

#define MPU6050_ADDRESS 0x68 << 1  //I2C Address contains only 7 bits
#define MPU6050_WHO_AM_I_ADDRESS 0x75
#define MPU6050_SMPLRT_DIV_REGISTER   0x19
#define MPU6050_DPLF_CONFIG_REGISTER  0x1A
#define MPU6050_GYRO_CONFIG_REGISTER  0x1B
#define MPU6050_ACCEL_CONFIG_REGISTER 0x1C
#define MPU6050_PWR_MGMT_1_REGISTER   0x6B
#define MPU6050_GYRO_OUT_REGISTER     0x43
#define MPU6050_ACCEL_OUT_REGISTER    0x3B

float dt = 0;
int16_t raw_ax = 0, raw_ay = 0, raw_az = 0, raw_gx = 0, raw_gy = 0, raw_gz = 0;
float gyroX = 0, gyroY = 0, gyroZ = 0, gyroX_offsets = 0, gyroY_offsets = 0, gyroZ_offsets = 0;
float accelX = 0, accelY = 0, accelZ = 0, accelX_offsets = 0, accelY_offsets = 0, accelZ_offsets = 0;
float angleX = 0, angleY = 0, angleZ = 0;

uint32_t current_Time = 0;
uint32_t prev_Time = 0;

uint8_t check;
HAL_StatusTypeDef status;
I2C_HandleTypeDef *IMU_HI2C;
TIM_HandleTypeDef *IMU_HTIM;

void MPU6050_Init(I2C_HandleTypeDef HI2C, TIM_HandleTypeDef HTIM){
	IMU_HI2C = &HI2C;
	IMU_HTIM = &HTIM;

	status = HAL_I2C_Mem_Read(&IMU_HI2C, MPU6050_ADDRESS, 0x75, 1, &check, 1, 1000);

	if (check == 0x68 || check == 0x70){
		mData = 0x00;
		HAL_I2C_Mem_Write(&IMU_HI2C, MPU6050_ADDRESS, 0x6B, 1, &mData, 1, 1000);

		mData = 0x07;
		HAL_I2C_Mem_Write(&IMU_HI2C, MPU6050_ADDRESS, 0x19, 1, &mData, 1, 1000);

		mData = 0x00;
		HAL_I2C_Mem_Write(&IMU_HI2C, MPU6050_ADDRESS, 0x1B, 1, &mData, 1, 1000);

		mData = 0x00;
		HAL_I2C_Mem_Write(&IMU_HI2C, MPU6050_ADDRESS, 0x1C, 1, &mData, 1, 1000);
	}
}
void MPU6050_GetAccel(){
	uint8_t accelData[6];

	HAL_I2C_Mem_Read(&IMU_HI2C, MPU6050_ADDRESS, 0x3B, 1, accelData, 6, 1000);

	raw_ax = (int16_t)(accelData[0] << 8) | (accelData[1]);
	raw_ay = (int16_t)(accelData[2] << 8) | (accelData[3]);
	raw_az = (int16_t)(accelData[4] << 8) | (accelData[5]);

	accelX = (float)raw_ax/16384.0f;
	accelY = (float)raw_ay/16384.0f;
	accelZ = (float)raw_az/16384.0f;
}

void MPU6050_GetGyro(){
	uint8_t gyroData[6];
	HAL_I2C_Mem_Read(&IMU_HI2C, MPU6050_ADDRESS, 0x43, 1, gyroData, 6, 1000);

	raw_gx = (int16_t)(gyroData[0] << 8) | (gyroData[1]);
	raw_gy = (int16_t)(gyroData[2] << 8) | (gyroData[3]);
	raw_gz = (int16_t)(gyroData[4] << 8) | (gyroData[5]);

	gyroX = (float)raw_gx/131.0f ;
	gyroX = (float)raw_gy/131.0f ;
	gyroZ = (float)raw_gz/131.0f ;
}

void MPU6050_Calibrate(void){
	float ag[] = {0, 0, 0, 0, 0, 0};

		for(int i = 0; i < 2000; i++){
			MPU6050_GetAccel();
			MPU6050_GetGyro();
			ag[0] += accelX;
			ag[1] += accelY;
			ag[2] += accelZ;
			ag[3] += gyroX;
			ag[4] += gyroY;
			ag[5] += gyroZ;
			HAL_Delay(1);
		}

		accelX_offsets = ag[0]/2000.0f;
		accelY_offsets = ag[1]/2000.0f;
		accelZ_offsets = ag[2]/2000.0f;
		gyroX_offsets = ag[3]/2000.0f;
		gyroY_offsets = ag[4]/2000.0f;
		gyroZ_offsets = ag[5]/2000.0f;
}

void MPU6050_GetFullReadings(){
	uint8_t accelBuffer[6];
	HAL_I2C_Mem_Read(&IMU_HI2C, MPU6050_ADDRESS, MPU6050_ACCEL_OUT_REGISTER, 1, accelBuffer, 6, 1000);

	raw_ax = (int16_t)(accelBuffer[0] << 8) | (accelBuffer[1]);
	raw_ay = (int16_t)(accelBuffer[2] << 8) | (accelBuffer[3]);
	raw_az = (int16_t)(accelBuffer[4] << 8) | (accelBuffer[5]);

	accelX = ((float)raw_ax/TEMP_LSB_OFFSET) - accelX_offsets;
	accelY = ((float)raw_ay/TEMP_LSB_OFFSET) - accelY_offsets;
	accelZ = ((float)raw_az/TEMP_LSB_OFFSET);
	//-------------------------------------------------------------------------------------------------------
	uint8_t gyroBuffer[6];
	HAL_I2C_Mem_Read(&IMU_HI2C, MPU6050_ADDRESS, MPU6050_GYRO_OUT_REGISTER, 1, gyroBuffer, 6, 1000);

	raw_gx = (int16_t)(gyroBuffer[0] << 8) | (gyroBuffer[1]);
	raw_gy = (int16_t)(gyroBuffer[2] << 8) | (gyroBuffer[3]);
	raw_gz = (int16_t)(gyroBuffer[4] << 8) | (gyroBuffer[5]);

	gyroX = ((float)raw_gx/TEMP_LSB_2_DEGREE)- gyroX_offsets;
	gyroY = ((float)raw_gy/TEMP_LSB_2_DEGREE)- gyroY_offsets;
	gyroZ = ((float)raw_gz/TEMP_LSB_2_DEGREE)- gyroZ_offsets;
}

void MPU6050_GetFilteredData(float filterGyroCoef){
	current_Time = __HAL_TIM_GET_COUNTER(&IMU_HTIM);
	dt = (float)(current_Time - prev_Time);
	dt = (dt)/1000000.0f;
	prev_Time = current_Time;

	float newAngleXGyro = angleX + (gyroX)*(dt);
	float newAngleYGyro = angleY + (gyroY)*(dt);

	float newAngleXAccel = atan2(accelY, sqrt(accelX*accelX + accelZ*accelZ)) * RAD_2_DEG;
	float newAngleYAccel = atan2(accelX, sqrt(accelY*accelY + accelZ*accelZ)) * RAD_2_DEG;

	angleX = (filterGyroCoef)*newAngleXGyro + (1.0f-(filterGyroCoef))*newAngleXAccel;
	angleY = (filterGyroCoef)*newAngleYGyro + (1.0f-(filterGyroCoef))*newAngleYAccel;
	angleZ += (gyroZ)*(dt);
}
